<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>AkariNet UI90</title>
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="manifest" href="./app.webmanifest">
    <meta charset="utf-8" />
    <link rel="apple-touch-icon" sizes="180x180" href="./apple-touch-icon.png">
    <link rel="shortcut icon" href="./favicon.ico">
    <meta name="msapplication-TileColor" content="#603cba">
  <style>
    html, body {
      margin: 0;
      padding: 0;
      background: black;
      width: 100vw;
      height: 100vh;
    }
    iframe {
      position: absolute;
      top: 50%;
      left: 50%;
      width: 100vh;
      height: 100vw;
      border: none;
      transform: rotate(90deg) translate(-50vw, 50vh);
      transform-origin: center;
      display: block;
    }
  </style>
<body>
    <iframe src="https://76836.github.io/Akari" allowfullscreen></iframe>
    <script>
        function requestFullscreen() {
            try {
                const el = document.documentElement;
                if (el.requestFullscreen) {
                    el.requestFullscreen().catch(() => {});
                } else if (el.webkitRequestFullscreen) {
                    el.webkitRequestFullscreen();
                } else if (el.mozRequestFullScreen) {
                    el.mozRequestFullScreen();
                } else if (el.msRequestFullscreen) {
                    el.msRequestFullscreen();
                }
            } catch (e) {}
        }

        // Try fullscreen on load
        window.addEventListener('load', requestFullscreen);

        // Try fullscreen on any possible user interaction
        [
            'click', 'dblclick', 'mousedown', 'mouseup', 'mousemove', 'keydown', 'keyup', 'keypress',
            'touchstart', 'touchend', 'touchmove', 'wheel', 'contextmenu', 'pointerdown', 'pointerup',
            'pointermove', 'focus', 'blur', 'mouseenter', 'mouseleave', 'mouseover', 'mouseout'
        ].forEach(evt => {
            window.addEventListener(evt, requestFullscreen, { once: false });
        });

        /**
 * Fake Media Player Keep-Alive Script
 * Creates a hidden video element and simulates playback to prevent page inactivity
 */

(function() {
    // Check if we're already running
    if (window._fakeMediaPlayerActive) {
        console.log('Fake media player is already active');
        return;
    }
    
    window._fakeMediaPlayerActive = true;
    
    // Create a minimal video element
    const video = document.createElement('video');
    video.id = 'fakeMediaPlayerKeepAlive';
    video.style.display = 'none';
    video.muted = true;
    video.loop = true;
    
    // Create a tiny video source (1px black frame)
    const canvas = document.createElement('canvas');
    canvas.width = 1;
    canvas.height = 1;
    const ctx = canvas.getContext('2d');
    ctx.fillStyle = 'black';
    ctx.fillRect(0, 0, 1, 1);
    
    // Convert canvas to video source
    const stream = canvas.captureStream(0.1); // Very low frame rate
    video.srcObject = stream;
    
    // Add to document
    document.body.appendChild(video);
    
    // Play/pause logic
    let isPlaying = false;
    const togglePlayback = () => {
        if (isPlaying) {
            video.pause();
            isPlaying = false;
        } else {
            video.play()
                .then(() => {
                    isPlaying = true;
                })
                .catch(err => {
                    console.error('Fake media player error:', err);
                });
        }
    };
    
    // Start with playback
    togglePlayback();
    
    // Set up interval to toggle playback periodically
    const intervalTime = 30000; // 30 seconds
    let keepAliveInterval = setInterval(togglePlayback, intervalTime);
    
    // Clean up function
    const cleanup = () => {
        clearInterval(keepAliveInterval);
        video.pause();
        if (video.srcObject) {
            video.srcObject.getTracks().forEach(track => track.stop());
        }
        video.remove();
        window._fakeMediaPlayerActive = false;
    };
    
    // Clean up when page unloads
    window.addEventListener('beforeunload', cleanup);
    
    // Expose cleanup method if needed
    window.fakeMediaPlayerKeepAlive = {
        stop: cleanup
    };
    
    console.log('Fake media player keep-alive activated');
})();
    //DeepSeek gave me the keep alive script, do you think it will work?
    </script>
</body>
</html>
